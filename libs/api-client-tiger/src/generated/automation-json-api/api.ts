// (C) 2025 GoodData Corporation

/* eslint-disable */
/**
 * OpenAPI definition
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from "./configuration.js";
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from "axios";
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common.js';
// Some imports not used depending on template conditions, we also need prettier-ignore so that the import does not get split and ts-ignore still works
// prettier-ignore
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base.js';

/**
 *
 * @export
 * @interface AdHocAutomation
 */
export interface AdHocAutomation {
    /**
     *
     * @type {string}
     * @memberof AdHocAutomation
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof AdHocAutomation
     */
    description?: string;
    /**
     * A list of tags.
     * @type {Array<string>}
     * @memberof AdHocAutomation
     */
    tags?: Array<string>;
    /**
     * Additional details to be included in the automated message.
     * @type {{ [key: string]: string; }}
     * @memberof AdHocAutomation
     */
    details?: { [key: string]: string };
    /**
     *
     * @type {AutomationMetadata}
     * @memberof AdHocAutomation
     */
    metadata?: AutomationMetadata | null;
    /**
     *
     * @type {Array<AutomationTabularExport>}
     * @memberof AdHocAutomation
     */
    tabularExports?: Array<AutomationTabularExport>;
    /**
     *
     * @type {Array<AutomationVisualExport>}
     * @memberof AdHocAutomation
     */
    visualExports?: Array<AutomationVisualExport>;
    /**
     * External recipients of the automation action results.
     * @type {Array<AutomationExternalRecipient>}
     * @memberof AdHocAutomation
     */
    externalRecipients?: Array<AutomationExternalRecipient>;
    /**
     *
     * @type {DeclarativeNotificationChannelIdentifier}
     * @memberof AdHocAutomation
     */
    notificationChannel?: DeclarativeNotificationChannelIdentifier;
    /**
     *
     * @type {Array<DeclarativeUserIdentifier>}
     * @memberof AdHocAutomation
     */
    recipients?: Array<DeclarativeUserIdentifier>;
    /**
     *
     * @type {DeclarativeAnalyticalDashboardIdentifier}
     * @memberof AdHocAutomation
     */
    analyticalDashboard?: DeclarativeAnalyticalDashboardIdentifier;
}
/**
 *
 * @export
 * @interface AlertDescription
 */
export interface AlertDescription {
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    metric: string;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    condition: string;
    /**
     *
     * @type {Array<AlertEvaluationRow>}
     * @memberof AlertDescription
     */
    currentValues?: Array<AlertEvaluationRow>;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    attribute?: string;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    totalValueCount?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    triggeredCount?: number;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    triggeredAt?: string;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    threshold?: number;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    formattedThreshold?: string;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    lowerThreshold?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    upperThreshold?: number;
    /**
     *
     * @type {number}
     * @memberof AlertDescription
     */
    remainingAlertEvaluationCount?: number;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    status?: AlertDescriptionStatusEnum;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    errorMessage?: string;
    /**
     *
     * @type {string}
     * @memberof AlertDescription
     */
    traceId?: string;
}

export const AlertDescriptionStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type AlertDescriptionStatusEnum =
    typeof AlertDescriptionStatusEnum[keyof typeof AlertDescriptionStatusEnum];

/**
 *
 * @export
 * @interface AlertEvaluationRow
 */
export interface AlertEvaluationRow {
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    primaryMetric?: MetricRecord;
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    secondaryMetric?: MetricRecord;
    /**
     *
     * @type {MetricRecord}
     * @memberof AlertEvaluationRow
     */
    computedMetric?: MetricRecord;
    /**
     *
     * @type {string}
     * @memberof AlertEvaluationRow
     */
    labelValue?: string;
}
/**
 *
 * @export
 * @interface AutomationExternalRecipient
 */
export interface AutomationExternalRecipient {
    /**
     * E-mail address to send notifications from.
     * @type {string}
     * @memberof AutomationExternalRecipient
     */
    email: string;
}
/**
 * Additional information for the automation.
 * @export
 * @interface AutomationMetadata
 */
export interface AutomationMetadata {
    /**
     *
     * @type {string}
     * @memberof AutomationMetadata
     */
    widget?: string;
    /**
     *
     * @type {Array<VisibleFilter>}
     * @memberof AutomationMetadata
     */
    visibleFilters?: Array<VisibleFilter>;
}
/**
 *
 * @export
 * @interface AutomationNotification
 */
export interface AutomationNotification extends NotificationContent {
    /**
     *
     * @type {WebhookMessage}
     * @memberof AutomationNotification
     */
    content: WebhookMessage;
}
/**
 *
 * @export
 * @interface AutomationNotificationAllOf
 */
export interface AutomationNotificationAllOf {
    /**
     *
     * @type {WebhookMessage}
     * @memberof AutomationNotificationAllOf
     */
    content?: WebhookMessage;
}
/**
 *
 * @export
 * @interface AutomationTabularExport
 */
export interface AutomationTabularExport {
    /**
     *
     * @type {TabularExportRequest}
     * @memberof AutomationTabularExport
     */
    requestPayload: TabularExportRequest;
}
/**
 *
 * @export
 * @interface AutomationVisualExport
 */
export interface AutomationVisualExport {
    /**
     *
     * @type {VisualExportRequest}
     * @memberof AutomationVisualExport
     */
    requestPayload: VisualExportRequest;
}
/**
 * Custom label object override.
 * @export
 * @interface CustomLabel
 */
export interface CustomLabel {
    /**
     * Override value.
     * @type {string}
     * @memberof CustomLabel
     */
    title: string;
}
/**
 * Custom metric object override.
 * @export
 * @interface CustomMetric
 */
export interface CustomMetric {
    /**
     * Metric title override.
     * @type {string}
     * @memberof CustomMetric
     */
    title: string;
    /**
     * Format override.
     * @type {string}
     * @memberof CustomMetric
     */
    format: string;
}
/**
 * Custom cell value overrides (IDs will be replaced with specified values).
 * @export
 * @interface CustomOverride
 */
export interface CustomOverride {
    /**
     * Map of CustomLabels with keys used as placeholders in document.
     * @type {{ [key: string]: CustomLabel; }}
     * @memberof CustomOverride
     */
    labels?: { [key: string]: CustomLabel };
    /**
     * Map of CustomMetrics with keys used as placeholders in document.
     * @type {{ [key: string]: CustomMetric; }}
     * @memberof CustomOverride
     */
    metrics?: { [key: string]: CustomMetric };
}
/**
 * An analytical dashboard identifier.
 * @export
 * @interface DeclarativeAnalyticalDashboardIdentifier
 */
export interface DeclarativeAnalyticalDashboardIdentifier {
    /**
     * Identifier of the analytical dashboard.
     * @type {string}
     * @memberof DeclarativeAnalyticalDashboardIdentifier
     */
    id: string;
    /**
     * A type.
     * @type {string}
     * @memberof DeclarativeAnalyticalDashboardIdentifier
     */
    type: DeclarativeAnalyticalDashboardIdentifierTypeEnum;
}

export const DeclarativeAnalyticalDashboardIdentifierTypeEnum = {
    ANALYTICAL_DASHBOARD: "analyticalDashboard",
} as const;

export type DeclarativeAnalyticalDashboardIdentifierTypeEnum =
    typeof DeclarativeAnalyticalDashboardIdentifierTypeEnum[keyof typeof DeclarativeAnalyticalDashboardIdentifierTypeEnum];

/**
 * A notification channel identifier.
 * @export
 * @interface DeclarativeNotificationChannelIdentifier
 */
export interface DeclarativeNotificationChannelIdentifier {
    /**
     * Notification channel identifier.
     * @type {string}
     * @memberof DeclarativeNotificationChannelIdentifier
     */
    id: string;
    /**
     * A type.
     * @type {string}
     * @memberof DeclarativeNotificationChannelIdentifier
     */
    type: DeclarativeNotificationChannelIdentifierTypeEnum;
}

export const DeclarativeNotificationChannelIdentifierTypeEnum = {
    NOTIFICATION_CHANNEL: "notificationChannel",
} as const;

export type DeclarativeNotificationChannelIdentifierTypeEnum =
    typeof DeclarativeNotificationChannelIdentifierTypeEnum[keyof typeof DeclarativeNotificationChannelIdentifierTypeEnum];

/**
 * A user identifier.
 * @export
 * @interface DeclarativeUserIdentifier
 */
export interface DeclarativeUserIdentifier {
    /**
     * User identifier.
     * @type {string}
     * @memberof DeclarativeUserIdentifier
     */
    id: string;
    /**
     * A type.
     * @type {string}
     * @memberof DeclarativeUserIdentifier
     */
    type: DeclarativeUserIdentifierTypeEnum;
}

export const DeclarativeUserIdentifierTypeEnum = {
    USER: "user",
} as const;

export type DeclarativeUserIdentifierTypeEnum =
    typeof DeclarativeUserIdentifierTypeEnum[keyof typeof DeclarativeUserIdentifierTypeEnum];

/**
 * Default SMTP destination for notifications.
 * @export
 * @interface DefaultSmtp
 */
export interface DefaultSmtp {
    /**
     * E-mail address to send notifications from. Currently this does not have any effect. E-mail \'no-reply@gooddata.com\' is used instead.
     * @type {string}
     * @memberof DefaultSmtp
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from. Currently this does not have any effect. E-mail from name \'GoodData\' is used instead.
     * @type {string}
     * @memberof DefaultSmtp
     */
    fromEmailName?: string;
    /**
     * The destination type.
     * @type {string}
     * @memberof DefaultSmtp
     */
    type: DefaultSmtpTypeEnum;
}

export const DefaultSmtpTypeEnum = {
    DEFAULT_SMTP: "DEFAULT_SMTP",
} as const;

export type DefaultSmtpTypeEnum = typeof DefaultSmtpTypeEnum[keyof typeof DefaultSmtpTypeEnum];

/**
 *
 * @export
 * @interface ExportResult
 */
export interface ExportResult {
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    fileName: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    exportId: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    status: ExportResultStatusEnum;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    fileUri?: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    errorMessage?: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    traceId?: string;
    /**
     *
     * @type {string}
     * @memberof ExportResult
     */
    triggeredAt?: string;
}

export const ExportResultStatusEnum = {
    SUCCESS: "SUCCESS",
    ERROR: "ERROR",
    INTERNAL_ERROR: "INTERNAL_ERROR",
    TIMEOUT: "TIMEOUT",
} as const;

export type ExportResultStatusEnum = typeof ExportResultStatusEnum[keyof typeof ExportResultStatusEnum];

/**
 * In-platform destination for notifications.
 * @export
 * @interface InPlatform
 */
export interface InPlatform {
    /**
     * The destination type.
     * @type {string}
     * @memberof InPlatform
     */
    type: InPlatformTypeEnum;
}

export const InPlatformTypeEnum = {
    IN_PLATFORM: "IN_PLATFORM",
} as const;

export type InPlatformTypeEnum = typeof InPlatformTypeEnum[keyof typeof InPlatformTypeEnum];

/**
 *
 * @export
 * @interface MetricRecord
 */
export interface MetricRecord {
    /**
     *
     * @type {number}
     * @memberof MetricRecord
     */
    value: number;
    /**
     *
     * @type {string}
     * @memberof MetricRecord
     */
    formattedValue?: string;
}
/**
 *
 * @export
 * @interface Notification
 */
export interface Notification {
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    workspaceId?: string;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    automationId?: string;
    /**
     *
     * @type {AutomationNotification | TestNotification}
     * @memberof Notification
     */
    data: AutomationNotification | TestNotification;
    /**
     *
     * @type {boolean}
     * @memberof Notification
     */
    isRead: boolean;
    /**
     *
     * @type {string}
     * @memberof Notification
     */
    createdAt: string;
}
/**
 * @type NotificationChannelDestination
 * @export
 */
export type NotificationChannelDestination = DefaultSmtp | InPlatform | Smtp | Webhook;

/**
 *
 * @export
 * @interface NotificationContent
 */
export interface NotificationContent {
    /**
     *
     * @type {string}
     * @memberof NotificationContent
     */
    type: string;
}
/**
 *
 * @export
 * @interface NotificationFilter
 */
export interface NotificationFilter {
    /**
     *
     * @type {string}
     * @memberof NotificationFilter
     */
    title: string;
    /**
     *
     * @type {string}
     * @memberof NotificationFilter
     */
    filter: string;
}
/**
 *
 * @export
 * @interface Notifications
 */
export interface Notifications {
    /**
     *
     * @type {Array<Notification>}
     * @memberof Notifications
     */
    data: Array<Notification>;
    /**
     *
     * @type {NotificationsMeta}
     * @memberof Notifications
     */
    meta: NotificationsMeta;
}
/**
 *
 * @export
 * @interface NotificationsMeta
 */
export interface NotificationsMeta {
    /**
     *
     * @type {NotificationsMetaTotal}
     * @memberof NotificationsMeta
     */
    total?: NotificationsMetaTotal;
}
/**
 *
 * @export
 * @interface NotificationsMetaTotal
 */
export interface NotificationsMetaTotal {
    /**
     *
     * @type {number}
     * @memberof NotificationsMetaTotal
     */
    unread: number;
    /**
     *
     * @type {number}
     * @memberof NotificationsMetaTotal
     */
    all: number;
}
/**
 * Custom CSS styles for the table. (PDF, HTML)
 * @export
 * @interface PdfTableStyle
 */
export interface PdfTableStyle {
    /**
     * CSS selector where to apply given properties.
     * @type {string}
     * @memberof PdfTableStyle
     */
    selector: string;
    /**
     * List of CSS properties.
     * @type {Array<PdfTableStyleProperty>}
     * @memberof PdfTableStyle
     */
    properties?: Array<PdfTableStyleProperty>;
}
/**
 * CSS property.
 * @export
 * @interface PdfTableStyleProperty
 */
export interface PdfTableStyleProperty {
    /**
     * CSS property key.
     * @type {string}
     * @memberof PdfTableStyleProperty
     */
    key: string;
    /**
     * CSS property value.
     * @type {string}
     * @memberof PdfTableStyleProperty
     */
    value: string;
}
/**
 * Additional settings.
 * @export
 * @interface Settings
 */
export interface Settings {
    /**
     * Merge equal headers in neighbouring cells. (XLSX)
     * @type {boolean}
     * @memberof Settings
     */
    mergeHeaders?: boolean;
    /**
     * Print applied filters on top of the document. (PDF/HTML when visualizationObject is given)
     * @type {boolean}
     * @memberof Settings
     */
    showFilters?: boolean;
    /**
     * Page size and orientation. (PDF)
     * @type {string}
     * @memberof Settings
     */
    pdfPageSize?: string;
    /**
     * Custom CSS styles for the table. (PDF, HTML)
     * @type {Array<PdfTableStyle>}
     * @memberof Settings
     */
    pdfTableStyle?: Array<PdfTableStyle>;
    /**
     * Top left header content. (PDF)
     * @type {string}
     * @memberof Settings
     */
    pdfTopLeftContent?: string;
    /**
     * Top right header content. (PDF)
     * @type {string}
     * @memberof Settings
     */
    pdfTopRightContent?: string;
}
/**
 * Custom SMTP destination for notifications. The properties host, port, username, and password are required on create and update
 * @export
 * @interface Smtp
 */
export interface Smtp {
    /**
     * E-mail address to send notifications from.
     * @type {string}
     * @memberof Smtp
     */
    fromEmail?: string;
    /**
     * An optional e-mail name to send notifications from.
     * @type {string}
     * @memberof Smtp
     */
    fromEmailName?: string;
    /**
     * The SMTP server address.
     * @type {string}
     * @memberof Smtp
     */
    host?: string;
    /**
     * The SMTP server port.
     * @type {number}
     * @memberof Smtp
     */
    port?: SmtpPortEnum;
    /**
     * The SMTP server username.
     * @type {string}
     * @memberof Smtp
     */
    username?: string;
    /**
     * The SMTP server password.
     * @type {string}
     * @memberof Smtp
     */
    password?: string;
    /**
     * The destination type.
     * @type {string}
     * @memberof Smtp
     */
    type: SmtpTypeEnum;
}

export const SmtpPortEnum = {
    NUMBER_25: 25,
    NUMBER_465: 465,
    NUMBER_587: 587,
    NUMBER_2525: 2525,
} as const;

export type SmtpPortEnum = typeof SmtpPortEnum[keyof typeof SmtpPortEnum];
export const SmtpTypeEnum = {
    SMTP: "SMTP",
} as const;

export type SmtpTypeEnum = typeof SmtpTypeEnum[keyof typeof SmtpTypeEnum];

/**
 * Export request object describing the export properties and overrides for tabular exports.
 * @export
 * @interface TabularExportRequest
 */
export interface TabularExportRequest {
    /**
     * Expected file format.
     * @type {string}
     * @memberof TabularExportRequest
     */
    format: TabularExportRequestFormatEnum;
    /**
     * Execution result identifier.
     * @type {string}
     * @memberof TabularExportRequest
     */
    executionResult?: string;
    /**
     * Filename of downloaded file without extension.
     * @type {string}
     * @memberof TabularExportRequest
     */
    fileName: string;
    /**
     *
     * @type {Settings}
     * @memberof TabularExportRequest
     */
    settings?: Settings;
    /**
     *
     * @type {CustomOverride}
     * @memberof TabularExportRequest
     */
    customOverride?: CustomOverride;
    /**
     * Visualization object identifier. Alternative to executionResult property.
     * @type {string}
     * @memberof TabularExportRequest
     */
    visualizationObject?: string;
    /**
     * Optional custom filters (as array of IFilter objects defined in UI SDK) to be applied when visualizationObject is given.
     * @type {Array<object>}
     * @memberof TabularExportRequest
     */
    visualizationObjectCustomFilters?: Array<object>;
    /**
     * Analytical dashboard identifier. Optional identifier, which informs the system that the export is related to a specific dashboard.
     * @type {string}
     * @memberof TabularExportRequest
     */
    relatedDashboardId?: string;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof TabularExportRequest
     */
    metadata?: object | null;
}

export const TabularExportRequestFormatEnum = {
    CSV: "CSV",
    XLSX: "XLSX",
    HTML: "HTML",
    PDF: "PDF",
} as const;

export type TabularExportRequestFormatEnum =
    typeof TabularExportRequestFormatEnum[keyof typeof TabularExportRequestFormatEnum];

/**
 * Request body with notification channel destination to test.
 * @export
 * @interface TestDestinationRequest
 */
export interface TestDestinationRequest {
    /**
     *
     * @type {DefaultSmtp | InPlatform | Smtp | Webhook}
     * @memberof TestDestinationRequest
     */
    destination: DefaultSmtp | InPlatform | Smtp | Webhook;
}
/**
 *
 * @export
 * @interface TestNotification
 */
export interface TestNotification extends NotificationContent {
    /**
     *
     * @type {string}
     * @memberof TestNotification
     */
    message: string;
}
/**
 *
 * @export
 * @interface TestNotificationAllOf
 */
export interface TestNotificationAllOf {
    /**
     *
     * @type {string}
     * @memberof TestNotificationAllOf
     */
    message?: string;
}
/**
 * Response from notification channel testing.
 * @export
 * @interface TestResponse
 */
export interface TestResponse {
    /**
     * A flag indicating whether test passed or not.
     * @type {boolean}
     * @memberof TestResponse
     */
    successful: boolean;
    /**
     * Field containing more details in case of a failure. Details are available to a privileged user only.
     * @type {string}
     * @memberof TestResponse
     */
    error?: string;
}
/**
 *
 * @export
 * @interface TriggerAutomationRequest
 */
export interface TriggerAutomationRequest {
    /**
     *
     * @type {AdHocAutomation}
     * @memberof TriggerAutomationRequest
     */
    automation: AdHocAutomation;
}
/**
 *
 * @export
 * @interface VisibleFilter
 */
export interface VisibleFilter {
    /**
     *
     * @type {string}
     * @memberof VisibleFilter
     */
    localIdentifier?: string;
    /**
     *
     * @type {string}
     * @memberof VisibleFilter
     */
    title?: string;
}
/**
 * Export request object describing the export properties and metadata for dashboard PDF exports.
 * @export
 * @interface VisualExportRequest
 */
export interface VisualExportRequest {
    /**
     * File name to be used for retrieving the pdf document.
     * @type {string}
     * @memberof VisualExportRequest
     */
    fileName: string;
    /**
     * Dashboard identifier
     * @type {string}
     * @memberof VisualExportRequest
     */
    dashboardId: string;
    /**
     * Metadata definition in free-form JSON format.
     * @type {object}
     * @memberof VisualExportRequest
     */
    metadata?: object;
}
/**
 * Webhook destination for notifications. The property url is required on create and update.
 * @export
 * @interface Webhook
 */
export interface Webhook {
    /**
     * The webhook URL.
     * @type {string}
     * @memberof Webhook
     */
    url?: string;
    /**
     * Bearer token for the webhook.
     * @type {string}
     * @memberof Webhook
     */
    token?: string | null;
    /**
     * Flag indicating if webhook has a token.
     * @type {boolean}
     * @memberof Webhook
     */
    hasToken?: boolean | null;
    /**
     * The destination type.
     * @type {string}
     * @memberof Webhook
     */
    type: WebhookTypeEnum;
}

export const WebhookTypeEnum = {
    WEBHOOK: "WEBHOOK",
} as const;

export type WebhookTypeEnum = typeof WebhookTypeEnum[keyof typeof WebhookTypeEnum];

/**
 *
 * @export
 * @interface WebhookAutomationInfo
 */
export interface WebhookAutomationInfo {
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof WebhookAutomationInfo
     */
    dashboardURL: string;
    /**
     *
     * @type {boolean}
     * @memberof WebhookAutomationInfo
     */
    isCustomDashboardURL: boolean;
}
/**
 *
 * @export
 * @interface WebhookMessage
 */
export interface WebhookMessage {
    /**
     *
     * @type {string}
     * @memberof WebhookMessage
     */
    timestamp: string;
    /**
     *
     * @type {WebhookMessageData}
     * @memberof WebhookMessage
     */
    data: WebhookMessageData;
    /**
     *
     * @type {string}
     * @memberof WebhookMessage
     */
    type: WebhookMessageTypeEnum;
}

export const WebhookMessageTypeEnum = {
    COMPLETED: "automation-task.completed",
    LIMIT_EXCEEDED: "automation-task.limit-exceeded",
} as const;

export type WebhookMessageTypeEnum = typeof WebhookMessageTypeEnum[keyof typeof WebhookMessageTypeEnum];

/**
 *
 * @export
 * @interface WebhookMessageData
 */
export interface WebhookMessageData {
    /**
     *
     * @type {WebhookAutomationInfo}
     * @memberof WebhookMessageData
     */
    automation: WebhookAutomationInfo;
    /**
     *
     * @type {Array<WebhookRecipient>}
     * @memberof WebhookMessageData
     */
    recipients?: Array<WebhookRecipient>;
    /**
     *
     * @type {{ [key: string]: string; }}
     * @memberof WebhookMessageData
     */
    details?: { [key: string]: string };
    /**
     *
     * @type {number}
     * @memberof WebhookMessageData
     */
    remainingActionCount?: number;
    /**
     *
     * @type {Array<ExportResult>}
     * @memberof WebhookMessageData
     */
    tabularExports?: Array<ExportResult>;
    /**
     *
     * @type {Array<ExportResult>}
     * @memberof WebhookMessageData
     */
    visualExports?: Array<ExportResult>;
    /**
     *
     * @type {AlertDescription}
     * @memberof WebhookMessageData
     */
    alert?: AlertDescription;
    /**
     *
     * @type {Array<NotificationFilter>}
     * @memberof WebhookMessageData
     */
    filters?: Array<NotificationFilter>;
}
/**
 *
 * @export
 * @interface WebhookRecipient
 */
export interface WebhookRecipient {
    /**
     *
     * @type {string}
     * @memberof WebhookRecipient
     */
    id: string;
    /**
     *
     * @type {string}
     * @memberof WebhookRecipient
     */
    email: string;
}

/**
 * ActionsApi - axios parameter creator
 * @export
 */
export const ActionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            if (isRead !== undefined) {
                localVarQueryParameter["isRead"] = isRead;
            }

            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification: async (
            notificationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists("markAsReadNotification", "notificationId", notificationId);
            const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
                `{${"notificationId"}}`,
                encodeURIComponent(String(notificationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll: async (
            workspaceId?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications/markAsRead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {TestDestinationRequest} [testDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            testDestinationRequest?: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            testDestinationRequest: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDestinationRequest' is not null or undefined
            assertParamExists("testNotificationChannel", "testDestinationRequest", testDestinationRequest);
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {TriggerAutomationRequest} triggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation: async (
            workspaceId: string,
            triggerAutomationRequest: TriggerAutomationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerAutomation", "workspaceId", workspaceId);
            // verify required parameter 'triggerAutomationRequest' is not null or undefined
            assertParamExists("triggerAutomation", "triggerAutomationRequest", triggerAutomationRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof triggerAutomationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(triggerAutomationRequest !== undefined ? triggerAutomationRequest : {})
                : triggerAutomationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation: async (
            workspaceId: string,
            automationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "automationId", automationId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * ActionsApi - functional programming interface
 * @export
 */
export const ActionsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = ActionsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(
                workspaceId,
                isRead,
                page,
                size,
                metaInclude,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotification(
            notificationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotification(
                notificationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotificationAll(
            workspaceId?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotificationAll(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {TestDestinationRequest} [testDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            testDestinationRequest?: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            testDestinationRequest: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {TriggerAutomationRequest} triggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerAutomation(
            workspaceId: string,
            triggerAutomationRequest: TriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerAutomation(
                workspaceId,
                triggerAutomationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerExistingAutomation(
            workspaceId: string,
            automationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerExistingAutomation(
                workspaceId,
                automationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * ActionsApi - factory interface
 * @export
 */
export const ActionsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = ActionsApiFp(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(
            requestParameters: ActionsApiGetNotificationsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Notifications> {
            return localVarFp
                .getNotifications(
                    requestParameters.workspaceId,
                    requestParameters.isRead,
                    requestParameters.page,
                    requestParameters.size,
                    requestParameters.metaInclude,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification(
            requestParameters: ActionsApiMarkAsReadNotificationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotification(requestParameters.notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {ActionsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll(
            requestParameters: ActionsApiMarkAsReadNotificationAllRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotificationAll(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: ActionsApiTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testExistingNotificationChannel(
                    requestParameters.notificationChannelId,
                    requestParameters.testDestinationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: ActionsApiTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.testDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {ActionsApiTriggerAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation(
            requestParameters: ActionsApiTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerAutomation(
                    requestParameters.workspaceId,
                    requestParameters.triggerAutomationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {ActionsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation(
            requestParameters: ActionsApiTriggerExistingAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerExistingAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * ActionsApi - interface
 * @export
 * @interface ActionsApi
 */
export interface ActionsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    getNotifications(
        requestParameters: ActionsApiGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Notifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    markAsReadNotification(
        requestParameters: ActionsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    markAsReadNotificationAll(
        requestParameters: ActionsApiMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testExistingNotificationChannel(
        requestParameters: ActionsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    testNotificationChannel(
        requestParameters: ActionsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsApiTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    triggerAutomation(
        requestParameters: ActionsApiTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApiInterface
     */
    triggerExistingAutomation(
        requestParameters: ActionsApiTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for getNotifications operation in ActionsApi.
 * @export
 * @interface ActionsApiGetNotificationsRequest
 */
export interface ActionsApiGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof ActionsApiGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof ActionsApiGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof ActionsApiGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in ActionsApi.
 * @export
 * @interface ActionsApiMarkAsReadNotificationRequest
 */
export interface ActionsApiMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof ActionsApiMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in ActionsApi.
 * @export
 * @interface ActionsApiMarkAsReadNotificationAllRequest
 */
export interface ActionsApiMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof ActionsApiMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in ActionsApi.
 * @export
 * @interface ActionsApiTestExistingNotificationChannelRequest
 */
export interface ActionsApiTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {TestDestinationRequest}
     * @memberof ActionsApiTestExistingNotificationChannel
     */
    readonly testDestinationRequest?: TestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in ActionsApi.
 * @export
 * @interface ActionsApiTestNotificationChannelRequest
 */
export interface ActionsApiTestNotificationChannelRequest {
    /**
     *
     * @type {TestDestinationRequest}
     * @memberof ActionsApiTestNotificationChannel
     */
    readonly testDestinationRequest: TestDestinationRequest;
}

/**
 * Request parameters for triggerAutomation operation in ActionsApi.
 * @export
 * @interface ActionsApiTriggerAutomationRequest
 */
export interface ActionsApiTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {TriggerAutomationRequest}
     * @memberof ActionsApiTriggerAutomation
     */
    readonly triggerAutomationRequest: TriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in ActionsApi.
 * @export
 * @interface ActionsApiTriggerExistingAutomationRequest
 */
export interface ActionsApiTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof ActionsApiTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof ActionsApiTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * ActionsApi - object-oriented interface
 * @export
 * @class ActionsApi
 * @extends {BaseAPI}
 */
export class ActionsApi extends BaseAPI implements ActionsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {ActionsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public getNotifications(
        requestParameters: ActionsApiGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .getNotifications(
                requestParameters.workspaceId,
                requestParameters.isRead,
                requestParameters.page,
                requestParameters.size,
                requestParameters.metaInclude,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {ActionsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public markAsReadNotification(
        requestParameters: ActionsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .markAsReadNotification(requestParameters.notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {ActionsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public markAsReadNotificationAll(
        requestParameters: ActionsApiMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .markAsReadNotificationAll(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {ActionsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testExistingNotificationChannel(
        requestParameters: ActionsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .testExistingNotificationChannel(
                requestParameters.notificationChannelId,
                requestParameters.testDestinationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {ActionsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public testNotificationChannel(
        requestParameters: ActionsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .testNotificationChannel(requestParameters.testDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {ActionsApiTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public triggerAutomation(
        requestParameters: ActionsApiTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .triggerAutomation(
                requestParameters.workspaceId,
                requestParameters.triggerAutomationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {ActionsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ActionsApi
     */
    public triggerExistingAutomation(
        requestParameters: ActionsApiTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return ActionsApiFp(this.configuration)
            .triggerExistingAutomation(requestParameters.workspaceId, requestParameters.automationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * AutomationsApi - axios parameter creator
 * @export
 */
export const AutomationsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {TriggerAutomationRequest} triggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation: async (
            workspaceId: string,
            triggerAutomationRequest: TriggerAutomationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerAutomation", "workspaceId", workspaceId);
            // verify required parameter 'triggerAutomationRequest' is not null or undefined
            assertParamExists("triggerAutomation", "triggerAutomationRequest", triggerAutomationRequest);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/trigger`.replace(
                `{${"workspaceId"}}`,
                encodeURIComponent(String(workspaceId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof triggerAutomationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(triggerAutomationRequest !== undefined ? triggerAutomationRequest : {})
                : triggerAutomationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation: async (
            workspaceId: string,
            automationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'workspaceId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "workspaceId", workspaceId);
            // verify required parameter 'automationId' is not null or undefined
            assertParamExists("triggerExistingAutomation", "automationId", automationId);
            const localVarPath = `/api/v1/actions/workspaces/{workspaceId}/automations/{automationId}/trigger`
                .replace(`{${"workspaceId"}}`, encodeURIComponent(String(workspaceId)))
                .replace(`{${"automationId"}}`, encodeURIComponent(String(automationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * AutomationsApi - functional programming interface
 * @export
 */
export const AutomationsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = AutomationsApiAxiosParamCreator(configuration);
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {string} workspaceId
         * @param {TriggerAutomationRequest} triggerAutomationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerAutomation(
            workspaceId: string,
            triggerAutomationRequest: TriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerAutomation(
                workspaceId,
                triggerAutomationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {string} workspaceId
         * @param {string} automationId
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async triggerExistingAutomation(
            workspaceId: string,
            automationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.triggerExistingAutomation(
                workspaceId,
                automationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * AutomationsApi - factory interface
 * @export
 */
export const AutomationsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = AutomationsApiFp(configuration);
    return {
        /**
         * Trigger the automation in the request.
         * @summary Trigger automation.
         * @param {AutomationsApiTriggerAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerAutomation(
            requestParameters: AutomationsApiTriggerAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerAutomation(
                    requestParameters.workspaceId,
                    requestParameters.triggerAutomationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Trigger the existing automation to execute immediately.
         * @summary Trigger existing automation.
         * @param {AutomationsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        triggerExistingAutomation(
            requestParameters: AutomationsApiTriggerExistingAutomationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .triggerExistingAutomation(
                    requestParameters.workspaceId,
                    requestParameters.automationId,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * AutomationsApi - interface
 * @export
 * @interface AutomationsApi
 */
export interface AutomationsApiInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsApiTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApiInterface
     */
    triggerAutomation(
        requestParameters: AutomationsApiTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApiInterface
     */
    triggerExistingAutomation(
        requestParameters: AutomationsApiTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;
}

/**
 * Request parameters for triggerAutomation operation in AutomationsApi.
 * @export
 * @interface AutomationsApiTriggerAutomationRequest
 */
export interface AutomationsApiTriggerAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsApiTriggerAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {TriggerAutomationRequest}
     * @memberof AutomationsApiTriggerAutomation
     */
    readonly triggerAutomationRequest: TriggerAutomationRequest;
}

/**
 * Request parameters for triggerExistingAutomation operation in AutomationsApi.
 * @export
 * @interface AutomationsApiTriggerExistingAutomationRequest
 */
export interface AutomationsApiTriggerExistingAutomationRequest {
    /**
     *
     * @type {string}
     * @memberof AutomationsApiTriggerExistingAutomation
     */
    readonly workspaceId: string;

    /**
     *
     * @type {string}
     * @memberof AutomationsApiTriggerExistingAutomation
     */
    readonly automationId: string;
}

/**
 * AutomationsApi - object-oriented interface
 * @export
 * @class AutomationsApi
 * @extends {BaseAPI}
 */
export class AutomationsApi extends BaseAPI implements AutomationsApiInterface {
    /**
     * Trigger the automation in the request.
     * @summary Trigger automation.
     * @param {AutomationsApiTriggerAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public triggerAutomation(
        requestParameters: AutomationsApiTriggerAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsApiFp(this.configuration)
            .triggerAutomation(
                requestParameters.workspaceId,
                requestParameters.triggerAutomationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Trigger the existing automation to execute immediately.
     * @summary Trigger existing automation.
     * @param {AutomationsApiTriggerExistingAutomationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AutomationsApi
     */
    public triggerExistingAutomation(
        requestParameters: AutomationsApiTriggerExistingAutomationRequest,
        options?: AxiosRequestConfig,
    ) {
        return AutomationsApiFp(this.configuration)
            .triggerExistingAutomation(requestParameters.workspaceId, requestParameters.automationId, options)
            .then((request) => request(this.axios, this.basePath));
    }
}

/**
 * NotificationChannelsApi - axios parameter creator
 * @export
 */
export const NotificationChannelsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications: async (
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "GET", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            if (isRead !== undefined) {
                localVarQueryParameter["isRead"] = isRead;
            }

            if (page !== undefined) {
                localVarQueryParameter["page"] = page;
            }

            if (size !== undefined) {
                localVarQueryParameter["size"] = size;
            }

            if (metaInclude) {
                localVarQueryParameter["metaInclude"] = Array.from(metaInclude);
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification: async (
            notificationId: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationId' is not null or undefined
            assertParamExists("markAsReadNotification", "notificationId", notificationId);
            const localVarPath = `/api/v1/actions/notifications/{notificationId}/markAsRead`.replace(
                `{${"notificationId"}}`,
                encodeURIComponent(String(notificationId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll: async (
            workspaceId?: string,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            const localVarPath = `/api/v1/actions/notifications/markAsRead`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (workspaceId !== undefined) {
                localVarQueryParameter["workspaceId"] = workspaceId;
            }

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {TestDestinationRequest} [testDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel: async (
            notificationChannelId: string,
            testDestinationRequest?: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'notificationChannelId' is not null or undefined
            assertParamExists(
                "testExistingNotificationChannel",
                "notificationChannelId",
                notificationChannelId,
            );
            const localVarPath = `/api/v1/actions/notificationChannels/{notificationChannelId}/test`.replace(
                `{${"notificationChannelId"}}`,
                encodeURIComponent(String(notificationChannelId)),
            );
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel: async (
            testDestinationRequest: TestDestinationRequest,
            options: AxiosRequestConfig = {},
        ): Promise<RequestArgs> => {
            // verify required parameter 'testDestinationRequest' is not null or undefined
            assertParamExists("testNotificationChannel", "testDestinationRequest", testDestinationRequest);
            const localVarPath = `/api/v1/actions/notificationChannels/test`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }
            const localVarRequestOptions = { method: "POST", ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            localVarHeaderParameter["Content-Type"] = "application/json";

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {
                ...localVarHeaderParameter,
                ...headersFromBaseOptions,
                ...options.headers,
            };
            const needsSerialization =
                typeof testDestinationRequest !== "string" ||
                localVarRequestOptions.headers["Content-Type"] === "application/json";
            localVarRequestOptions.data = needsSerialization
                ? JSON.stringify(testDestinationRequest !== undefined ? testDestinationRequest : {})
                : testDestinationRequest || "";

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    };
};

/**
 * NotificationChannelsApi - functional programming interface
 * @export
 */
export const NotificationChannelsApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = NotificationChannelsApiAxiosParamCreator(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {string} [workspaceId] Workspace ID to filter notifications by.
         * @param {boolean} [isRead] Filter notifications by read status.
         * @param {string} [page] Zero-based page index (0..N)
         * @param {string} [size] The size of the page to be returned.
         * @param {Array<'total' | 'ALL'>} [metaInclude] Additional meta information to include in the response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNotifications(
            workspaceId?: string,
            isRead?: boolean,
            page?: string,
            size?: string,
            metaInclude?: Array<"total" | "ALL">,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Notifications>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNotifications(
                workspaceId,
                isRead,
                page,
                size,
                metaInclude,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {string} notificationId Notification ID to mark as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotification(
            notificationId: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotification(
                notificationId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {string} [workspaceId] Workspace ID where to mark notifications as read.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsReadNotificationAll(
            workspaceId?: string,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsReadNotificationAll(
                workspaceId,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {string} notificationChannelId
         * @param {TestDestinationRequest} [testDestinationRequest]
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testExistingNotificationChannel(
            notificationChannelId: string,
            testDestinationRequest?: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testExistingNotificationChannel(
                notificationChannelId,
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {TestDestinationRequest} testDestinationRequest
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async testNotificationChannel(
            testDestinationRequest: TestDestinationRequest,
            options?: AxiosRequestConfig,
        ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TestResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.testNotificationChannel(
                testDestinationRequest,
                options,
            );
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    };
};

/**
 * NotificationChannelsApi - factory interface
 * @export
 */
export const NotificationChannelsApiFactory = function (
    configuration?: Configuration,
    basePath?: string,
    axios?: AxiosInstance,
) {
    const localVarFp = NotificationChannelsApiFp(configuration);
    return {
        /**
         * Get latest in-platform notifications for the current user.
         * @summary Get latest notifications.
         * @param {NotificationChannelsApiGetNotificationsRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNotifications(
            requestParameters: NotificationChannelsApiGetNotificationsRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<Notifications> {
            return localVarFp
                .getNotifications(
                    requestParameters.workspaceId,
                    requestParameters.isRead,
                    requestParameters.page,
                    requestParameters.size,
                    requestParameters.metaInclude,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark in-platform notification by its ID as read.
         * @summary Mark notification as read.
         * @param {NotificationChannelsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotification(
            requestParameters: NotificationChannelsApiMarkAsReadNotificationRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotification(requestParameters.notificationId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Mark all user in-platform notifications as read.
         * @summary Mark all notifications as read.
         * @param {NotificationChannelsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsReadNotificationAll(
            requestParameters: NotificationChannelsApiMarkAsReadNotificationAllRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<void> {
            return localVarFp
                .markAsReadNotificationAll(requestParameters.workspaceId, options)
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the existing notification channel by sending a test notification.
         * @summary Test existing notification channel.
         * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testExistingNotificationChannel(
            requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testExistingNotificationChannel(
                    requestParameters.notificationChannelId,
                    requestParameters.testDestinationRequest,
                    options,
                )
                .then((request) => request(axios, basePath));
        },
        /**
         * Tests the notification channel by sending a test notification.
         * @summary Test notification channel.
         * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        testNotificationChannel(
            requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
            options?: AxiosRequestConfig,
        ): AxiosPromise<TestResponse> {
            return localVarFp
                .testNotificationChannel(requestParameters.testDestinationRequest, options)
                .then((request) => request(axios, basePath));
        },
    };
};

/**
 * NotificationChannelsApi - interface
 * @export
 * @interface NotificationChannelsApi
 */
export interface NotificationChannelsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    getNotifications(
        requestParameters: NotificationChannelsApiGetNotificationsRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<Notifications>;

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    markAsReadNotification(
        requestParameters: NotificationChannelsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    markAsReadNotificationAll(
        requestParameters: NotificationChannelsApiMarkAsReadNotificationAllRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<void>;

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    testExistingNotificationChannel(
        requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApiInterface
     */
    testNotificationChannel(
        requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ): AxiosPromise<TestResponse>;
}

/**
 * Request parameters for getNotifications operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiGetNotificationsRequest
 */
export interface NotificationChannelsApiGetNotificationsRequest {
    /**
     * Workspace ID to filter notifications by.
     * @type {string}
     * @memberof NotificationChannelsApiGetNotifications
     */
    readonly workspaceId?: string;

    /**
     * Filter notifications by read status.
     * @type {boolean}
     * @memberof NotificationChannelsApiGetNotifications
     */
    readonly isRead?: boolean;

    /**
     * Zero-based page index (0..N)
     * @type {string}
     * @memberof NotificationChannelsApiGetNotifications
     */
    readonly page?: string;

    /**
     * The size of the page to be returned.
     * @type {string}
     * @memberof NotificationChannelsApiGetNotifications
     */
    readonly size?: string;

    /**
     * Additional meta information to include in the response.
     * @type {Array<'total' | 'ALL'>}
     * @memberof NotificationChannelsApiGetNotifications
     */
    readonly metaInclude?: Array<"total" | "ALL">;
}

/**
 * Request parameters for markAsReadNotification operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiMarkAsReadNotificationRequest
 */
export interface NotificationChannelsApiMarkAsReadNotificationRequest {
    /**
     * Notification ID to mark as read.
     * @type {string}
     * @memberof NotificationChannelsApiMarkAsReadNotification
     */
    readonly notificationId: string;
}

/**
 * Request parameters for markAsReadNotificationAll operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiMarkAsReadNotificationAllRequest
 */
export interface NotificationChannelsApiMarkAsReadNotificationAllRequest {
    /**
     * Workspace ID where to mark notifications as read.
     * @type {string}
     * @memberof NotificationChannelsApiMarkAsReadNotificationAll
     */
    readonly workspaceId?: string;
}

/**
 * Request parameters for testExistingNotificationChannel operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiTestExistingNotificationChannelRequest
 */
export interface NotificationChannelsApiTestExistingNotificationChannelRequest {
    /**
     *
     * @type {string}
     * @memberof NotificationChannelsApiTestExistingNotificationChannel
     */
    readonly notificationChannelId: string;

    /**
     *
     * @type {TestDestinationRequest}
     * @memberof NotificationChannelsApiTestExistingNotificationChannel
     */
    readonly testDestinationRequest?: TestDestinationRequest;
}

/**
 * Request parameters for testNotificationChannel operation in NotificationChannelsApi.
 * @export
 * @interface NotificationChannelsApiTestNotificationChannelRequest
 */
export interface NotificationChannelsApiTestNotificationChannelRequest {
    /**
     *
     * @type {TestDestinationRequest}
     * @memberof NotificationChannelsApiTestNotificationChannel
     */
    readonly testDestinationRequest: TestDestinationRequest;
}

/**
 * NotificationChannelsApi - object-oriented interface
 * @export
 * @class NotificationChannelsApi
 * @extends {BaseAPI}
 */
export class NotificationChannelsApi extends BaseAPI implements NotificationChannelsApiInterface {
    /**
     * Get latest in-platform notifications for the current user.
     * @summary Get latest notifications.
     * @param {NotificationChannelsApiGetNotificationsRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public getNotifications(
        requestParameters: NotificationChannelsApiGetNotificationsRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .getNotifications(
                requestParameters.workspaceId,
                requestParameters.isRead,
                requestParameters.page,
                requestParameters.size,
                requestParameters.metaInclude,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark in-platform notification by its ID as read.
     * @summary Mark notification as read.
     * @param {NotificationChannelsApiMarkAsReadNotificationRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public markAsReadNotification(
        requestParameters: NotificationChannelsApiMarkAsReadNotificationRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .markAsReadNotification(requestParameters.notificationId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Mark all user in-platform notifications as read.
     * @summary Mark all notifications as read.
     * @param {NotificationChannelsApiMarkAsReadNotificationAllRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public markAsReadNotificationAll(
        requestParameters: NotificationChannelsApiMarkAsReadNotificationAllRequest = {},
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .markAsReadNotificationAll(requestParameters.workspaceId, options)
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the existing notification channel by sending a test notification.
     * @summary Test existing notification channel.
     * @param {NotificationChannelsApiTestExistingNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public testExistingNotificationChannel(
        requestParameters: NotificationChannelsApiTestExistingNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .testExistingNotificationChannel(
                requestParameters.notificationChannelId,
                requestParameters.testDestinationRequest,
                options,
            )
            .then((request) => request(this.axios, this.basePath));
    }

    /**
     * Tests the notification channel by sending a test notification.
     * @summary Test notification channel.
     * @param {NotificationChannelsApiTestNotificationChannelRequest} requestParameters Request parameters.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof NotificationChannelsApi
     */
    public testNotificationChannel(
        requestParameters: NotificationChannelsApiTestNotificationChannelRequest,
        options?: AxiosRequestConfig,
    ) {
        return NotificationChannelsApiFp(this.configuration)
            .testNotificationChannel(requestParameters.testDestinationRequest, options)
            .then((request) => request(this.axios, this.basePath));
    }
}
